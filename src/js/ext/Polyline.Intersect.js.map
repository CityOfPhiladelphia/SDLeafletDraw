{"version":3,"sources":["../../es6/ext/Polyline.Intersect.js"],"names":[],"mappings":";;AAUA;;;;AAEA;;;;;;AAZA;;;;;;;;;;AAeA,kBAAE,QAAF,CAAW,OAAX,CAAmB;;AAEjB;;;;AAIA,YANiB,wBAMK;AACpB,QAAI,KAAK,4BAAL,EAAJ,EAAyC;AACvC,aAAO,KAAP;AACD;;AAED,QAAM,SAAS,KAAK,mBAAL,EAAf;AACA,QAAM,MAAM,SAAS,OAAO,MAAhB,GAAyB,CAArC;;AAEA,SAAK,IAAI,IAAI,MAAM,CAAnB,EAAsB,KAAK,CAA3B,EAA8B,KAAK,CAAnC,EAAsC;AACpC,UAAM,IAAI,OAAO,IAAI,CAAX,CAAV;AACA,UAAM,KAAK,OAAO,CAAP,CAAX;;AAEA,UAAI,KAAK,4BAAL,CAAkC,CAAlC,EAAqC,EAArC,EAAyC,IAAI,CAA7C,CAAJ,EAAqD;AACnD,eAAO,IAAP;AACD;AACF;;AAED,WAAO,KAAP;AACD,GAxBgB;;;AA0BjB;;;;AAIA,qBA9BiB,+BA8BG,MA9BH,EA8BqB,SA9BrB,EA8BkD;AACjE;AACA,QAAI,CAAC,KAAK,IAAV,EACE,OAAO,KAAP;;AAEF,WAAO,KAAK,kBAAL,CAAwB,KAAK,IAAL,CAAU,kBAAV,CAA6B,MAA7B,CAAxB,EAA8D,SAA9D,CAAP;AACD,GApCgB;;;AAsCjB;;;;;AAKA,oBA3CiB,8BA2CE,QA3CF,EA2CqB,SA3CrB,EA2CkD;AACjE,QAAI,KAAK,4BAAL,CAAkC,CAAlC,CAAJ,EACE,OAAO,KAAP;;AAEF,QAAM,SAAS,KAAK,mBAAL,EAAf;AACA,QAAM,MAAM,SAAS,OAAO,MAAhB,GAAyB,CAArC;AACA,QAAM,YAAY,SAAS,OAAO,MAAM,CAAb,CAAT,GAA2B,IAA7C;AACA;AACA,QAAM,WAAW,MAAM,CAAvB;;AAEA,WAAO,KAAK,4BAAL,CAAkC,SAAlC,EAA6C,QAA7C,EAAuD,QAAvD,EAAiE,YAAY,CAAZ,GAAgB,CAAjF,CAAP;AACD,GAtDgB;;;AAwDjB;;;;;AAKA,8BA7DiB,wCA6DY,WA7DZ,EA6D0C;AACzD,QAAM,SAAS,KAAK,mBAAL,EAAf;AACA,QAAI,MAAM,SAAS,OAAO,MAAhB,GAAyB,CAAnC;AACA;AACA,WAAO,eAAe,CAAtB;;AAEA,WAAO,CAAC,MAAD,IAAW,OAAO,CAAzB;AACD,GApEgB;;;AAsEjB;;;;AAIA,8BA1EiB,wCA0EY,CA1EZ,EA0EwB,EA1ExB,EA2EY,QA3EZ,EA2E8B,QA3E9B,EA2EyD;AACxE,QAAM,SAAS,KAAK,mBAAL,EAAf;;AAEA,QAAM,eAAe,YAAY,CAAjC;;AAEA;AACA,SAAK,IAAI,IAAI,QAAb,EAAuB,IAAI,YAA3B,EAAyC,KAAK,CAA9C,EAAiD;AAC/C,UAAM,KAAK,OAAO,IAAI,CAAX,CAAX;AACA,UAAM,KAAK,OAAO,CAAP,CAAX;;AAEA,UAAI,mBAAkB,iBAAlB,CAAoC,CAApC,EAAuC,EAAvC,EAA2C,EAA3C,EAA+C,EAA/C,CAAJ,EAAwD;AACtD,eAAO,IAAP;AACD;AACF;;AAED,WAAO,KAAP;AACD,GA3FgB;AA6FjB,qBA7FiB,iCA6FqB;AAAA;;AACpC,QAAI,CAAC,KAAK,aAAV,EACE,OAAO,KAAK,eAAZ;;AAEF,WAAO,KAAK,aAAL,GAAqB,GAArB,CAAyB;AAAA,aAAK,MAAK,IAAL,CAAU,kBAAV,CAA6B,CAA7B,CAAL;AAAA,KAAzB,CAAP;AACD;AAlGgB,CAAnB","file":"Polyline.Intersect.js","sourcesContent":["/** @flow\n * StratoDem Analytics : Polyline.Intersect\n * Principal Author(s) : Michael Clawar\n * Secondary Author(s) :\n * Description :\n *\n *  (c) 2016- StratoDem Analytics, LLC\n *  All Rights Reserved\n */\n\nimport L from 'leaflet';\n\nimport LineUtilIntersect from './LineUtil.Intersect';\n\n\nL.Polyline.include({\n\n  /**\n   * Check to see if this polyline has any linesegments that intersect.\n   * NOTE: does not support detecting intersection for degenerate cases.\n   **/\n  intersects(): boolean {\n    if (this._tooFewPointsForIntersection()) {\n      return false;\n    }\n\n    const points = this._getProjectedPoints();\n    const len = points ? points.length : 0;\n\n    for (let i = len - 1; i >= 3; i -= 1) {\n      const p = points[i - 1];\n      const p1 = points[i];\n\n      if (this._lineSegmentsIntersectsRange(p, p1, i - 2)) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * Check for intersection if new latlng was added to this polyline\n   * NOTE: Does not support detecting intersection for degenerate cases.\n   */\n  newLatLngIntersects(latlng: L.LatLng, skipFirst: boolean): boolean {\n    // Cannot check a polyline for intersecting lats/lngs when not added to the map\n    if (!this._map)\n      return false;\n\n    return this.newPointIntersects(this._map.latLngToLayerPoint(latlng), skipFirst);\n  },\n\n  /**\n   * Check for intersection if new point was added to this polyline\n   * newPoint must be a layer point\n   * NOTE: Does not support detecting intersection for degenerate cases.\n   */\n  newPointIntersects(newPoint: L.Point, skipFirst: boolean): boolean {\n    if (this._tooFewPointsForIntersection(1))\n      return false;\n\n    const points = this._getProjectedPoints();\n    const len = points ? points.length : 0;\n    const lastPoint = points ? points[len - 1] : null;\n    // The previous previous line segment. Previous line segment doesn't need testing.\n    const maxIndex = len - 2;\n\n    return this._lineSegmentsIntersectsRange(lastPoint, newPoint, maxIndex, skipFirst ? 1 : 0);\n  },\n\n  /**\n   * Polylines with 2 sides can only intersect in cases where points are collinear\n   * (we don't support detecting these).\n   * Cannot have intersection when < 3 line segments (< 4 points)\n   */\n  _tooFewPointsForIntersection(extraPoints: number): boolean {\n    const points = this._getProjectedPoints();\n    let len = points ? points.length : 0;\n    // Increment length by extraPoints if present\n    len += extraPoints || 0;\n\n    return !points || len <= 3;\n  },\n\n  /**\n   * Checks a line segment intersection with any line segment before its predecessor.\n   * Don't need to check the predecessor as it will never intersect.\n   */\n  _lineSegmentsIntersectsRange(p: L.Point, p1: L.Point,\n                               maxIndex: number, minIndex: number): boolean {\n    const points = this._getProjectedPoints();\n\n    const nextMinIndex = minIndex || 0;\n\n    // Check all previous line segments (beside the immediately previous) for intersections\n    for (let j = maxIndex; j > nextMinIndex; j -= 1) {\n      const p2 = points[j - 1];\n      const p3 = points[j];\n\n      if (LineUtilIntersect.segmentsIntersect(p, p1, p2, p3)) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n\n  _getProjectedPoints(): Array<L.Point> {\n    if (!this._defaultShape)\n      return this._originalPoints;\n\n    return this._defaultShape().map(s => this._map.latLngToLayerPoint(s));\n  },\n});\n"]}